

Transcrição
[00:00] Agora que já tivemos essa introdução aos 5 conceitos principais da orientação a objeto, vamos ver o que chamamos de SOLID, que é um conjunto de design patterns, de padrão de design de código, desenvolvido para orientação a objeto, eles começaram a ser compilados nos anos 80 e foram definidos e centralizados pelos anos 2000. Vamos ver letra por letra desse acrônimo e o que elas significam.

[00:31] Então, a primeira letra é o S, de Single responsibility principle, princípio da responsabilidade única. O que isso significa? Significa que cada módulo, cada classe, cada método, só tem que ter um motivo para mudar, para sofrer alterações, para executar código.

[00:56] Podemos melhorar essa explicação da seguinte forma, digamos que o módulo é responsável por uma, e somente uma entidade. Chama ator ou entidade do nosso projeto. No caso, um usuário é uma entidade no nosso projeto. E tem que fazer coisas relativas apenas a essa entidade. Muita gente confunde essa responsabilidade única como fazer só uma tarefa, não precisa necessariamente ser isso. Uma classe tem que tratar somente de users. E os métodos internos dela, quando começamos a trabalhar com funções, nós aprendemos, os métodos internos fazem coisas muito específicas, tarefas específicas.

[01:37] Mas uma classe é responsável por uma entidade e os métodos internos dela são responsáveis por uma tarefa. Então, cada parte do código, cada módulo ela faz uma coisa só, ela só tem uma responsabilidade.

[01:52] Então, por exemplo, um exemplo não tão bom que poderíamos colocar na classe user. Então, os métodos de uma classe, como eu já falei, elas tem que dizer respeito somente a user, somente a essa entidade. No caso, temos um método de exibir as informações de user, tudo bem, porque são as informações do usuário. Mas digamos que os usuários tem que pagar os boletos da plataforma e colocamos dentro de user um método para processar os pagamentos desse usuário, o que já não é tão bom, porque agora além de lidar com as informações do usuário, com as coisas que são referentes ao que o usuário faz, também que lidar com partes do negócio que não são do usuário, que são de pagamento.

[02:36] Então, processar pagamento não é uma coisa que o usuário tem que fazer, é uma parte de pagamento, então teria uma classe própria para isso, uma classe pagamento, por exemplo, não uma classe user.

[02:49] Então poderíamos separar, então temos a classe user, que exibe as informações de user, que trata de tudo que é relacionado a ele, e tem uma parte de uma classe de pagamento, que trabalha com a parte de processar pagamentos. Essa parte de processar pagamento recebe, no caso do nosso projeto, não trabalhamos com uma base dados, mas em um contexto maior você teria um ID de usuário, que então seria passado para dentro de pagamento, e processado o pagamento deste ID de usuário. Mas isso não é uma responsabilidade do usuário, da classe usuário.

[03:29] Então essa separação evita muito problema, porque se deixássemos tudo em usuário, ficaria tudo muito acoplado. E quando é muito acoplado, é muito difícil entender o que está acontecendo, é muito difícil debugar, é muito difícil reaproveitar código, testar, então quem chega para trabalhar no seu sistema, não sabe em que parte do sistema está acontecendo cada coisa, e complica para todo mundo.

[03:55] Esse foi o primeiro, foi o S, o O, de SOLID, significa open/closed principle, ou seja, o princípio do aberto/fechado. É um nome meio esquisito, mas aberto e fechado nesse caso, significa que a classe tem que estar aberta para ser expandida, porém fechada, para ser modificada. Ou seja, a ideia nesse caso, é que seja possível adicionar funcionalidades em uma classe, mas não alterar métodos de uma classe que já existem e que já estão em funcionamento ou alterar essas classes mesmo.

[04:30] Então, por exemplo, supondo que a classe user tem que retornar os dados de um usuário de uma forma diferente, porque tem uma funcionalidade nova que precisa fazer um relatório. Então, não modificamos o método exibirInfos, que já existe, adicionamos um novo método para atender essa nova demanda. Então, por exemplo, um método exibirRelatorio, que vai mandar as informações para fora, do jeito que a funcionalidade nova está pedindo.

[04:58] Então, não mexendo no que já está implementado, diminui a probabilidade de quebrar alguma coisa que estava funcionando, e também de acabarmos implementando bugs, como costumamos dizer.

[05:13] O princípio do aberto/fechado está muito ligado a um conceito em OO, orientação a objetos, que não temos no JavaScript, que são as chamadas interfaces. Elas existem no TypeScript, que é um superset do JavaScript, mas eu vou deixar um material extra sobre as interfaces, explicando o que elas são, como elas são utilizadas, mas o JavaScript em si, não tem interfaces implementadas.

[05:44] Então, indo em frente, o terceiro princípio é o L, de Liskov substitution principle, o princípio da substituição de Liskov. Liskov é Barbara Liskov, uma cientista da computação, que foi quem pensou, quem primeiro formalizou isso que chamamos de princípio de substituição. Então, é porque o princípio é dela, e não porque a Barbara Liskov vai ser substituída.

[06:09] Então, isso significa que, se temos uma subclasse e uma superclasse, ou seja, uma classe que herda da outra, deveria ser possível sempre substituir uma pela outra, sem que nada deixe de funcionar. Como assim? Em outras palavras, se uma classe tem um atributo, a subclasse dela também tem que ter. Se algo funciona na superclasse, tem que funcionar na subclasse também. Ou seja, uma subclasse não pode fazer o que chamamos de quebrar contratos feitos pela superclasse. Ou seja, uma coisa que está estabelecida pela superclasse, não pode ser quebrada pela subclasse.

[06:52] Como assim? Então, novamente, voltando ao nosso método exibirInfos, esse princípio está muito ligado ao que conversamos anteriormente sobre polimorfismo, e dá para ver isso no método exibirInfos, que foi o teste que fizemos quando conversamos sobre polimorfismo. Ou seja, exibirInfos, que deriva da superclasse, é utilizada pela subclasse da mesma forma, mesmo com um comportamento interno diferente. Então, o método que tem na superclasse é o método que tem na subclasse.

[07:25] O I de SOLID é interface segregation principle, que é o princípio de segregação de interface. Então, esse princípio diz que clientes não devem ser forçados a depender de interfaces que eles não usam. Vamos dar uma explicada, sem utilizar interfaces. Basicamente, esse princípio diz que não podemos impor uma implementação de uma coisa que não vai ser necessária. Por exemplo, eu, Juliana, sou vegetariana, então minha classe Juliana não utilizaria métodos, por exemplo, que envolvam carne, todos os métodos que envolvem carne na classe Juliana são desnecessários.

[08:10] Então, não podemos impor que a minha classe Juliana tenha um método que não vai usar. Como o JavaScript, novamente, não tem interfaces, esse princípio não tem como ser aplicado diretamente usando JavaScript, porque as interfaces estabelecem contratos, ou seja, elas estabelecem o que deve ser implementado toda vez que instanciamos uma classe. E não ter isso no JavaScript, não termos esse comportamento de implementação forçada, digamos assim. Vou deixar, novamente, o material extra, para você conferir o que são as interfaces, e esse princípio vai fazer um pouco mais de sentido.

[08:52] E o último, o D, é o dependency inversion principle, que é o princípio da inversão de dependência. Ou seja, digamos que módulos que estão em um nível mais acima da hierarquia de classes, não podem depender de nada que está abaixo deles, e também diz que nenhum deles podem depender de implementações, e sim, de abstrações. Como explicamos isso?

[09:20] Quando falamos de abstração, estamos falando de esconder detalhes de como uma coisa funciona. Então, usamos um computador, utilizamos as interfaces do computador mesmo, o teclado é uma interface do computador, então a interface entre o computador e o ser humano, todas as entradas USB são interfaces por onde nos comunicamos com o computador, mas não vemos por dentro o funcionamento dele, o funcionamento dele, interno, teoricamente, não para nós que estudamos e trabalhamos na área, mas para o usuário do computador, a implementação interna do computador, como ele funciona por dentro, não é uma coisa que ele precisa saber, uma coisa que interessa.

[10:04] Ou seja, a questão de abstração é abstrair os detalhes de como determinado método funciona, e não fazer com que tudo seja implementado junto. Então esse D, fala sobre abstração, sobre justamente encapsularmos as coisas, escondermos como determinada função funciona, determinado método funciona, e apenas quem usa os módulos, quem usa os métodos só tem que saber da abstração, eu sei que digitar coisas no teclado, vão aparecer as letras na tela, e como isso está implementado internamente, não é minha responsabilidade saber.

[10:44] Vamos usar como exemplo a classe user. Então supondo que tenhamos dados de user, suponde que estamos usando algum banco de dados para guardar esses dados, e esses dados precisam ser salvos em algum lugar, em algum tipo de banco. E podemos criar um método salvarDados, que vai ser chamado na hora de salvar esses dados, e dentro dele, criamos uma instância de uma classe chamada const db = new ConcexaoSQL, e a partir dessa instância de conexão SQL, dessa nova conexão que criamos, salvando na variável DB, faz toda a lógica de salvar os dados do usuário no banco.

[11:28] Porém, se pensarmos que as entidades não tem que depender de uma implementação, elas tem que depender de uma abstração, é justamente o que está acontecendo nesse caso, o método está chamando diretamente uma conexão SQL, ou seja, está acoplando desnecessariamente a implementação de como esses dados vão ser salvos, ao invés de uma abstração.

[11:55] E se mudamos o banco, agora não é mais SQL, agora vamos usar um no sequel, temos que sair alterando todas as instâncias em que isso foi feito? Vamos ver como isso ficaria, para ficar de acordo com esse princípio do D.

[12:09] Por exemplo, na classe user, onde criamos a nova instância de conexão, nós criamos uma nova instância de conexão, abstraímos como é feita a lógica interna de conexão, para quem usa, ou seja, a classe user, ela não precisa saber se a conexão é SQL, se é feita pelo Mongo, como isso é feito, ela só precisa saber que os dados serão salvos. Ou seja, passamos para dentro de user uma nova conexão, e os detalhes ficam ocultos dentro da classe conexão, ou seja, dentro da classe conexão podemos ter os métodos ConexaoSQL, ConexaoMongo.

[12:51] E dependendo da conexão dos dados que a classe receber, ela define internamente se vai chamar o método SQL, se vai chamar o método Mongo. Mas para quem está fora de conexão, e é isso que chamamos de abstração versus implementação, os detalhes da implementação ficam ocultos, o que a classe user usa e sabe usar é a abstração, sabe que vai acontecer uma conexão, vão salvar os meus dados e é disso que eu preciso, eu preciso dos meus dados salvos. Como isso vai acontecer, não é responsabilidade da classe user, é responsabilidade da classe conexão.

[13:26] Com isso, nós fechamos essa apresentação aos princípios do SOLID, tem N materiais sobre SOLID, tem material didático, tem vídeo, tem tese, tem trabalho de faculdade feito sobre isso, um tema vasto, o que demos é só uma introdução, e agora com esse conteúdo fechamos nossos primeiros passos em orientação a objetos com JavaScript.

CONTINUAR LENDO
